# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

AUTHOR = 'Chromium OS team'
NAME = 'tast.cellular_ota-starfishplus'
METADATA = {
    "contacts": ["chromeos-cellular-team@google.com"],
    "bug_component": "b:167157", # ChromeOS > Platform > Connectivity > Cellular
    }
TIME = 'MEDIUM'
TEST_TYPE = 'Server'
ATTRIBUTES = 'suite:cellular_ota'
MAX_RESULT_SIZE_KB = 1024 * 1024
PY_VERSION = 3
DEPENDENCIES = "carrier:starfishplus"

DOC = '''
Run the stable Tast tests which verify basic Cellular functionality.

"group:cellular" indicates that the test runs on DUTs with a Cellular modem.
"cellular_sim_active": Used to select tests that require a sim card.

Tast is an integration-testing framework analagous to the test-running portion
of Autotest. See https://chromium.googlesource.com/chromiumos/platform/tast/ for
more information.

See http://go/tast-failures for information about investigating failures.
'''

import json
import tempfile
import yaml
from autotest_lib.client.common_lib import error
from autotest_lib.utils import labellib

def run(machine):
    host = hosts.create_host(machine)
    labels = host.host_info_store.get().labels
    slotMapping = labellib.LabelsMapping(labels).get('starfish_slot_mapping')
    # slotMapping = "0_att,1_fi,2_tmobile,3_verizon"
    if not slotMapping:
        # any setup that has the label 'carrier:starfishplus' should have
        # the starfish_slot_mapping label populated.
        raise error.TestError('starfish_slot_mapping label not set.')
    slots = slotMapping.split(',')
    for c in slots:
        c.strip()
        xs = c.split('_')
        if len(xs) != 2:
            raise error.TestError('error parsing starfish_slot_mapping label.')
        index = xs[0]
        carrier = xs[1]
        index.strip()
        carrier.strip()
        with tempfile.NamedTemporaryFile(suffix='.yaml', mode='w+') as temp_file:
            svars = ['starfish.type=starfishplus','starfish.carrier='+carrier,'starfish.index='+index]
            yaml.safe_dump({'autotest_host_info_labels':
                            json.dumps(labels)},
                            stream=temp_file)
            temp_file.flush()
            testgroups = {
                          "0_is_modem_up":["cellular.IsModemUp"],
                          "1_dut_check":["cellular.Identifiers","cellular.IsConnected."+carrier,"cellular.Smoke."+carrier,"cellular.SmokeIPConnectivity."+carrier],
                          "2_autoconnect_enable":["cellular.ShillAutoconnect","cellular.ShillEnableDisable"],
                          "3_platform":['("group:cellular" && "cellular_sim_active" && !"cellular_unstable" && !"cellular_run_isolated" && !"cellular_e2e")'],
                          "4_suspend_resume":['("group:cellular" && "cellular_sim_active" && !"cellular_unstable" && "cellular_suspend")'],
                          "5_e2e":['("group:cellular" && "cellular_sim_active" && !"cellular_unstable" && "cellular_e2e" && (!"cellular_carrier_dependent" || "cellular_carrier_'+carrier+'"))'],
                         }
            host.reboot()
            for testsession in sorted(testgroups):
                sessiontag = testsession+"_"+carrier
                tast_test_expr = testgroups[testsession]
                job.run_test('tast',
                             host=host,
                             test_exprs=tast_test_expr,
                             clear_tpm = False,
                             ignore_test_failures=True, max_run_sec=10800,
                             command_args=args,
                             varsfiles=[temp_file.name],
                             varslist=svars,
                             tag=sessiontag)
                job.clear_post_run_hooks()

parallel_simple(run, machines)
