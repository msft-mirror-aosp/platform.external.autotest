# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import logging
import os

from autotest_lib.server.cros import chrome_sideloader
from autotest_lib.server import utils

AUTHOR = 'ChromeOS SW Engprod Team (chromeos-sw-engprod@google.com)'
METADATA = {
    'contacts': ['chromeos-sw-engprod@google.com'],
    'bug_component': 'b:1034523', # ChromeOS > Test > Harness > Tauto
    'criteria': 'Runs Tast tests with custom Ash Chrome binaries',
    'hw_agnostic': False
}
NAME = 'tast.chrome-from-gcs'
TEST_TYPE = 'Server'
MAX_RESULT_SIZE_KB = 1024 * 1024

# tast.py uses binaries installed from autotest_server_package.tar.bz2.
REQUIRE_SSP = True

# This mount point controls the version of chrome to use
CHROME_MOUNT_POINT = '/opt/google/chrome'
# Location where chromite deploys chrome artifacts.
CHROME_DIR = '/usr/local/opt/google/chrome'
# Location where chromite deploys Lacros artifacts.
LACROS_DIR = '/usr/local/lacros-chrome'

DOC = '''
Runs Tast tests with custom Ash Chrome binaries.

This control file is a generic wrapper for running Tast tests
from Chromium builders using the Chromium Skylab recipe.

Chromium builders create Ash Chrome binaries and upload to GCS.
The archive is expected to include chromite which in turn is used to deploy
chrome onto the DUT.

This control file expects tast_expr or tast_expr_b64 argument to determine
the set of tast tests to be executed.

Example for tast_expr: test_that --args="tast_expr=nearbyshare.SmokeMultiDUTUI"

Example for tast_expr_b64:
  In Python:
    tast_expr = '("group:mainline" && !informational)'
    tast_expr_b64 = base64.b64encode(tast_expr.encode('utf-8')).decode('ascii')
    # Yields 'KCJncm91cDptYWlubGluZSIgJiYgIWluZm9ybWF0aW9uYWwp'
  Then in Autotest CLI:'
    test_that --args="tast_expr_b64=KCJncm91cDptYWlubGluZSIgJiYgIWluZm9ybWF0aW9uYWwp"

More details at go/lacros-on-skylab.
'''


def run(machine):
    host = hosts.create_host(machine)
    varslist = []
    args_dict = utils.args_to_dict(args)

    # Setup DUT to use the chrome binary from gcs archive.
    chrome_dir = chrome_sideloader.chromite_deploy_chrome(host,
                                                          args_dict.get('lacros_gcs_path'),
                                                          'chrome',**args_dict)

    tast_expr = chrome_sideloader.get_tast_expr_from_local_file(args_dict, chrome_dir)
    if not tast_expr:
        tast_expr = chrome_sideloader.get_tast_expr(args_dict)
    logging.info('Tast expr: %s', tast_expr)

    # If chrome archive contains Lacros, chromite will also deploy Lacros.
    lacros_dir = os.path.join(chrome_dir, 'out/Release/lacros_clang/')
    if os.path.exists(lacros_dir):
        varslist.append('lacros.DeployedBinary=%s' % LACROS_DIR)

    run_private_tests=args_dict.get('run_private_tests', 'true') == 'true'
    total_shards=args_dict.get('total_shards', 1)
    shard_index=args_dict.get('shard_index', 0)
    max_run_sec=int(args_dict.get('max_run_sec', 21600)) # 6 hours.
    retries=int(args_dict.get('retries', 1))
    logging.info("Running %s on host: %s with Tast expression:%s "
                 "total_shards: %s shard_index: %s max_run_sec: %s",
                 NAME, host, tast_expr, total_shards, shard_index, max_run_sec)

    # Register a clean up callback to reset the chrome mount.
    def cleanup():
        chrome_sideloader.cleanup_host(host, CHROME_DIR, CHROME_MOUNT_POINT)
        chrome_sideloader.cleanup_host(host, LACROS_DIR, None)
    job.add_post_run_hook(cleanup)

    job.run_test('tast',
                 host=host,
                 test_exprs=[tast_expr],
                 download_data_lazily=False,
                 ignore_test_failures=False,
                 retries=retries,
                 max_run_sec=max_run_sec,
                 command_args=args,
                 varslist=varslist,
                 totalshards=total_shards,
                 shardindex=shard_index,
                 clear_tpm=False,
                 run_private_tests=run_private_tests)

parallel_simple(run, machines)
