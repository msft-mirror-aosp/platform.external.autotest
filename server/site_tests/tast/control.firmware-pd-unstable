# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

from autotest_lib.client.common_lib import utils
from autotest_lib.server.site_tests.tast import tast

AUTHOR = 'ChromiumOS Firmware EngProd team'
NAME = 'tast.firmware-pd-unstable'
METADATA = {
        "contacts": ["chromeos-faft@google.com", "jbettis@chromium.org"],
        "bug_component": "b:792402", # ChromeOS > Platform > Enablement > Firmware > FAFT
        "criteria": "Servo based USB PD tests",
}
TIME = 'LONG'
TEST_TYPE = 'Server'
DEPENDENCIES = 'servo_state:WORKING'
ATTRIBUTES = 'suite:faft_pd_unstable'
MAX_RESULT_SIZE_KB = 1024 * 1024
JOB_RETRIES = 0

# tast.py uses binaries installed from autotest_server_package.tar.bz2.
REQUIRE_SSP = True

DOC = '''
This is the firmware-pd-unstable test suite. The tests in this suites verify the
behaviors of the USB-C Power Delivery (PD) stack, like establishing a PD
contract, hard and soft resets, data role swap, power role swap, VBUS voltage
negotiation, etc. Besides, the suite test ULP mode related tests since they have
the same servo setup requirements.

This suite only tests a single Type-C port connecting to the PDTester device
(Servo v4 or Servo v4p1). DUTs with multiple Type-C ports should run this
suite multiple time for all the Type-C ports.

The tests are part of 'group:firmware'. The 'firmware_pd_unstable' sub-attribute
limits it to PD tests that are experimental or not yet stable.
'''

command_args, varslist = tast.split_arguments(args)
args_dict = utils.args_to_dict(command_args)
assert 'servo_state:WORKING' in DEPENDENCIES
servo_args = hosts.CrosHost.get_servo_arguments(args_dict)

def run(machine):
    job.run_test('tast',
                 host=hosts.create_host(machine, servo_args=servo_args),
                 test_exprs=['("group:firmware" && firmware_pd_unstable)'],
                 ignore_test_failures=True, max_run_sec=10800,
                 command_args=command_args,
                 varslist=varslist)

parallel_simple(run, machines)
