# Copyright 2018 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

from autotest_lib.server import utils

AUTHOR = "mqg"
NAME = "power_ServodWrapper"
PURPOSE = "Measure power with servod while running a client test."
CRITERIA = "This test is a wrapper for a client test."
TIME = "LONG"
TEST_CATEGORY = "Benchmark"
TEST_CLASS = "power"
TEST_TYPE = "server"
DEPENDENCIES = "servo_state:WORKING"
PY_VERSION = 3

DOC = """
This wrapper test automates the process of power measurement with servod while
running a client test. Please check the client test's control file for any
hardware requirement, e.g. no AC power, no Ethernet.

This test makes the following assumptions:
1. Servod is already running, and its host and port are provided to this
autotest.

2. The workstation (or where the autotest is kicked off from) should be in same
timezone with the DUT.

Sample usage:
test_that <ip address of DUT> power_ServodWrapper --args \
'test=power_LoadTest.fast servo_host=localhost servo_port=9999 \
adc_rate=20 adc_accum_rate=60 vbat_rate=60'

What are the parameters:
test: the client test to run in wrapper test; DUT power is measured during this
      client test; required.
servo_host: host of servod instance; required.
servo_port: port that the servod instance is on; required.
adc_rate: power measurement from ADCs are logged every adc_rate seconds;
          optional.
adc_accum_rate: power measurement from ADCs with an accumulator are logged
                every adc_accum_rate seconds*; optional.
vbat_rate: power measurement from EC is logged every vbat_rate seconds;
           optional.
note: User supplied note to tag the specific test; optional.


* A note on ADCs with and without accumulator. The accumulator can accumulate
measurements in hardware at a much higher sampling speed than our software
tools. We can then grab the average of those measurements at the
|adc_accum_rate|. This has a few implications
1. The dut-power code (underlying this functionality) will prefer to use the
   accumulator over collecting individual samples in a loop.
   Therefore, when an accumulator is available, it will be used, and sampled
   at |adc_accum_rate| rather than |adc_rate|.
2. The system automatically identifies whether a rail has an accumulator.
3. If you wish to run without accumulator functionality - which you
   really should not - set |adc_accum_rate| to 0.
4. The accumulators are *large* - meaning you won't lose samples at higher
   sampling rates - however, you lose time-step granularity. Meaning a sampling
   rate of 60s and 1s will collect the exact same number of samples on the ADC
   but you will see 1 value or 60 values in the output depending on the rate
   - this might be useful for debugging.
"""

# Workaround to make it compatible with moblab autotest UI.
global args_dict
try:
    args_dict
except NameError:
    args_dict = utils.args_to_dict(args)
servo_args = hosts.CrosHost.get_servo_arguments(args_dict)

def run(machine):
    host = hosts.create_host(machine, servo_args=servo_args)
    job.run_test("power_ServodWrapper", host=host, config=args_dict)

parallel_simple(run, machines)
